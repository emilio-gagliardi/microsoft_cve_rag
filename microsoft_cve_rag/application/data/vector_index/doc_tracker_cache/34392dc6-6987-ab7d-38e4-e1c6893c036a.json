{"node_id": "34392dc6-6987-ab7d-38e4-e1c6893c036a", "text": "Thank you for\nsharing, Emin, This script assumes that the primary disk is 0. This is not the\ncase on about 15% of my managed devices. They were born with PCIE+SSD or SSD+HDD\nand harddisk0 is the large storage disk, not the OS+WinRE disk, which is usually\n1 on these devices. On one of my file servers with many drives the OS+WinRE disk\nis disk 4. We're parsing \"reagentc.exe /info\" for the correct primary disk and\nusing that number in ours: === $winreloc = (reagentc /info | select-string\n\"Windows RE location:\\s+(([^\\r\\n]+)disk(\\d+)\\\\partition(\\d+)\\\\([^\\r\\n]+))\");\n$winrepath = $winreloc.Matches.groups[1].value.trim() $winredisk =\n$winreloc.Matches.groups[3].value $winrepart = $winreloc.Matches.groups[4].value\nWrite-Host \"WinRE is at disk $winredisk partition $winrepart\" === With that we\npass $winrepath to Get-Volume to obtain the size to see if it is large enough\n(minimum 1GB in the code below) without modification and proceed if necessary:\n=== $winresize = (Get-Volume -FilePath $winrepath | select SizeRemaining,Size )\nif ($winresize.Size -lt 1GB) { Write-Host WinRE needs to be larger. } else {\nWrite-Host WinRE is large enough. } === From that point on wherever you would\nuse a static 0 in the script just replace it with $winredisk A check to\ndetermine if the OS partition is before or after the WinRE partition is also\nnecessary. This would determine if you needed to juggle part 2 to a new 4 or\njust shrink 2 and recreate 3 (usually). It would be best to compare the WinOS\ndisk and $winredisk before repartitioning here, too, since one of my clients\nuses a dangerous multiple disk setup where the OS is on disk 0 and WinRE and\nData are on disk 1. My understanding is that this was done so they could easily\nswap out their OS disk without having to worry about losing data, but WinRE\nisn't stable and whenever they swap out the OS drive recovery is impossible. I\nhave tried to convince them to put WinRE on the system drive but they're not\nreceptive. They would rather not use WinRE at all (but don't want to remove it\nfor some reason) and just reimage each time. === $pridisk = (Get-Disk |\nWhere-Object IsSystem -eq $True) $pripart = $pridisk.PartitionStyle $windisk =\n$pridisk.Number $winpart = (Get-Partition -DriveLetter (Get-WmiObject\nwin32_volume | where { \"$env:windir\".StartsWith( $_.name\n,\"CurrentCultureIgnoreCase\") } | sort { $_.name.length } -desc | select -First\n1).DriveLetter[0]).PartitionNumber Write-Host \"WinOS is at disk $windisk\npartition $winpart\" if ($windisk -eq $winredisk) { Write-Host WinRE and WinOS\nare on the same disk. if ($winpart -lt $winrepart) { Write-Host WinRE can be\nsafely resized. } else { Write-Host WinRE will need to be moved. } } else {\nWrite-Host WinRE and WinOS are on different disks. } === I also recommend\nrepartitioning part 2 on those where creating a part 4 is necessary, so that\nsome later script or tool doesn't just \"reagentc /disable, reagentc /enable\" and\nit assumes the now invalid part 2 instead of the new part 4. Recreating it\nmanually the way you do in your script is fine if you can rely on nothing coming\nafter you but I wouldn't trust it. MS is eventually going to automate some more\nof this and that's going to cause havok. -S\nLink: None", "embedding": null, "excluded_embed_metadata_keys": ["id", "added_to_vector_store", "added_to_summary_index", "added_to_graph_store", "cve_fixes", "cve_mentions", "email_text_original", "unique_tokens", "tags"], "excluded_llm_metadata_keys": ["id", "added_to_vector_store", "added_to_summary_index", "added_to_graph_store", "cve_fixes", "cve_mentions", "email_text_original", "unique_tokens", "tags"], "metadata": {"id": "34392dc6-6987-ab7d-38e4-e1c6893c036a", "receivedDateTime": "2024-01-13T22:08:23+00:00", "topic": "Feedback to Microsoft", "subject": "RE: [patchmanagement] Feedback to Microsoft", "published": "2024-01-13T00:00:00", "collection": "patch_management", "cve_fixes": "", "cve_mentions": null, "tags": "", "conversation_link": "N/A", "email_text_original": "[You don't often get email from patchmanagement.org@12pd.com. Learn why this is\nimportant at https://aka.ms/LearnAboutSenderIdentification ] Thank you for\nsharing, Emin, This script assumes that the primary disk is 0. This is not the\ncase on about 15% of my managed devices. They were born with PCIE+SSD or SSD+HDD\nand harddisk0 is the large storage disk, not the OS+WinRE disk, which is usually\n1 on these devices. On one of my file servers with many drives the OS+WinRE disk\nis disk 4. We're parsing \"reagentc.exe /info\" for the correct primary disk and\nusing that number in ours: === $winreloc = (reagentc /info | select-string\n\"Windows RE location:\\s+(([^\\r\\n]+)disk(\\d+)\\\\partition(\\d+)\\\\([^\\r\\n]+))\");\n$winrepath = $winreloc.Matches.groups[1].value.trim() $winredisk =\n$winreloc.Matches.groups[3].value $winrepart = $winreloc.Matches.groups[4].value\nWrite-Host \"WinRE is at disk $winredisk partition $winrepart\" === With that we\npass $winrepath to Get-Volume to obtain the size to see if it is large enough\n(minimum 1GB in the code below) without modification and proceed if necessary:\n=== $winresize = (Get-Volume -FilePath $winrepath | select SizeRemaining,Size )\nif ($winresize.Size -lt 1GB) { Write-Host WinRE needs to be larger. } else {\nWrite-Host WinRE is large enough. } === From that point on wherever you would\nuse a static 0 in the script just replace it with $winredisk A check to\ndetermine if the OS partition is before or after the WinRE partition is also\nnecessary. This would determine if you needed to juggle part 2 to a new 4 or\njust shrink 2 and recreate 3 (usually). It would be best to compare the WinOS\ndisk and $winredisk before repartitioning here, too, since one of my clients\nuses a dangerous multiple disk setup where the OS is on disk 0 and WinRE and\nData are on disk 1. My understanding is that this was done so they could easily\nswap out their OS disk without having to worry about losing data, but WinRE\nisn't stable and whenever they swap out the OS drive recovery is impossible. I\nhave tried to convince them to put WinRE on the system drive but they're not\nreceptive. They would rather not use WinRE at all (but don't want to remove it\nfor some reason) and just reimage each time. === $pridisk = (Get-Disk |\nWhere-Object IsSystem -eq $True) $pripart = $pridisk.PartitionStyle $windisk =\n$pridisk.Number $winpart = (Get-Partition -DriveLetter (Get-WmiObject\nwin32_volume | where { \"$env:windir\".StartsWith( $_.name\n,\"CurrentCultureIgnoreCase\") } | sort { $_.name.length } -desc | select -First\n1).DriveLetter[0]).PartitionNumber Write-Host \"WinOS is at disk $windisk\npartition $winpart\" if ($windisk -eq $winredisk) { Write-Host WinRE and WinOS\nare on the same disk. if ($winpart -lt $winrepart) { Write-Host WinRE can be\nsafely resized. } else { Write-Host WinRE will need to be moved. } } else {\nWrite-Host WinRE and WinOS are on different disks. } === I also recommend\nrepartitioning part 2 on those where creating a part 4 is necessary, so that\nsome later script or tool doesn't just \"reagentc /disable, reagentc /enable\" and\nit assumes the now invalid part 2 instead of the new part 4. Recreating it\nmanually the way you do in your script is fine if you can rely on nothing coming\nafter you but I wouldn't trust it. MS is eventually going to automate some more\nof this and that's going to cause havok. -S\nLink: None \n", "evaluated_keywords": "['dangerous multiple disk setup', 'correct primary disk', 'large storage disk', 'os drive recovery']", "evaluated_noun_chunks": "['the primary disk', 'my managed devices', 'the OS+WinRE disk', 'the correct primary disk']", "post_type": "Solution provided", "unique_tokens": 239, "thread_id": "feedback_microsoft", "previous_id": "0eb0045d-4a08-db52-1b63-5706c65f9404", "next_id": "a5d33d2b-0aef-a882-d77c-7cb11b249d9e", "etl_processing_status": {"document_processed": true, "entities_extracted": false, "graph_prepared": false, "vector_prepared": false, "last_processed_at": "2025-01-03T22:51:54.420805+00:00", "processing_version": "1.0"}, "noun_chunks": "['the primary disk', 'my managed devices', 'the OS+WinRE disk', 'the correct primary disk']", "keywords": "['dangerous multiple disk setup', 'correct primary disk', 'large storage disk', 'os drive recovery']", "node_label": "PatchManagementPost", "kb_ids": [], "cve_ids": "", "build_numbers": [], "product_mentions": [], "is_processed": false}, "added_at": "2025-01-03T16:00:36.374964", "last_updated": "2025-01-03T16:02:29.242238"}